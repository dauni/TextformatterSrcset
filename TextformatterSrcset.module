<?php

class TextformatterSrcset extends Textformatter implements ConfigurableModule {

	/**
	 * Module settings
	 *
	 */

	protected static $defaultConfigData = array(

		// settings
		"resolutions" => "350,700", //Only numbers, seperated by comma
		"medias" => "799,800", //Only numbers, seperated by comma
		"borders" => "max-width,min-width", //Only numbers, seperated by comma
		"sizes" => "auto", //What to put into the sizes attribute
		"retina" => true, //Create an image double the largest image size for HiDPI devices
		"data_attr" => false, //Add the data-* attributes
		"wh_attr" => false, //Should we add width and height attributes?
		"lqp" => true, //Use a low quality placeholder for the src attribute
		"small_source" => false, //Use the smallest size as a source image instead of a scaled down image
		"class" => '', //Classes added to the image
		"ls_attr" => false, //Inlcude automatically lazysizes.js and add corresponding data-attributes
		"wp_attr" => false //Generate WEBP-Version (Since processwire 3.0.132)


	);
	protected $data = array();

	/**
	 * Set all settings to data
	 *
	 */

	public function __construct() {
		foreach (self::$defaultConfigData as $key => $value) {
			$this->data[$key] = $value;
		}
	} // module data

	/**
	 * Module information
	 *
	 */

	public static function getModuleInfo() {
		return array(
			'title' => 'Srcset Image Textformatter',
			'version' => 101,
			'summary' => "Adds the srcset to images within a textarea",
			'author' => 'Conclurer GbR'
		);
	}

	/**
	 * Return an InputfieldsWrapper of Inputfields used to configure the class
	 *
	 * @param array $data Array of config values indexed by field name
	 * @return InputfieldWrapper
	 *
	 */
	public static function getModuleConfigInputfields(array $data) {
		$data = array_merge(self::$defaultConfigData, $data);
		$wrapper = new InputfieldWrapper();

		$resolutionsInput = wire('modules')->get('InputfieldText');
		$resolutionsInput->name = 'resolutions';
		$resolutionsInput->columnWidth = 33;
		$resolutionsInput->label = __('Resolutions');
		$resolutionsInput->description = __('Enter the resolutions (in Pixel) to be created for the srcset. Seperate by comma, leave empty if you do not need multiple sizes.');
		$resolutionsInput->value = $data['resolutions'];
		$wrapper->add($resolutionsInput);

		$mediasInput = wire('modules')->get('InputfieldText');
		$mediasInput->name = 'medias';
		$mediasInput->columnWidth = 33;
		$mediasInput->label = __('Medias');
		$mediasInput->description = __('Enter the medias (in Pixel) to be created for the srcset - corresponding to the image-resolutions. Seperate by comma, leave empty if you do not need multiple sizes.');
		$mediasInput->value = $data['medias'];
		$wrapper->add($mediasInput);

		$bordersInput = wire('modules')->get('InputfieldText');
		$bordersInput->name = 'borders';
		$bordersInput->columnWidth = 34;
		$bordersInput->label = __('Borders');
		$bordersInput->description = __('Enter the borders (min-width/max-width) - corresponding to the image-resolutions and medias. Seperate by comma, leave empty if you do not need multiple sizes.');
		$bordersInput->value = $data['borders'];
		$wrapper->add($bordersInput);

		$sizesInput = wire('modules')->get('InputfieldText');
		$sizesInput->name = 'sizes';
		$sizesInput->columnWidth = 50;
		$sizesInput->label = __('Sizes-Attribute');
		$sizesInput->description = __('Enter the value for the "sizes" attribute. Default is "auto".');
		$sizesInput->value = $data['sizes'];
		$wrapper->add($sizesInput);

		$classInput = wire('modules')->get('InputfieldText');
		$classInput->name = 'class';
		$classInput->columnWidth = 50;
		$classInput->label = __('CSS Class');
		$classInput->description = __('Enter CSS-class names that will be added to each image.');
		$classInput->value = $data['class'];
		$wrapper->add($classInput);

		$retinaInput = wire('modules')->get('InputfieldCheckbox');
		$retinaInput->name = 'retina';
		$retinaInput->label = __('Generate HiDPI images');
		$retinaInput->description = __('Activate to create HiDPI images (double resolution). They appear as an additional size.');
		if (!empty($data['retina'])) $retinaInput->checked = 1;
		$wrapper->add($retinaInput);

		$lqpInput = wire('modules')->get('InputfieldCheckbox');
		$lqpInput->name = 'lqp';
		$lqpInput->columnWidth = 33;
		$lqpInput->label = __('Low-quality Placeholder');
		$lqpInput->description = __('Activate to create a low-quality placeholder (LQP) image for the src-attribute.');
		if (!empty($data['lqp'])) $lqpInput->checked = 1;
		$wrapper->add($lqpInput);

		$small_sourceInput = wire('modules')->get('InputfieldCheckbox');
		$small_sourceInput->name = 'small_source';
		$small_sourceInput->columnWidth = 33;
		$small_sourceInput->label = __('Use smallest size as LQP');
		$small_sourceInput->description = __('Activate to use the smallest sized image as the low-quality placeholder');
		if (!empty($data['small_source'])) $small_sourceInput->checked = 1;
		$wrapper->add($small_sourceInput);

		$wp_attrInput = wire('modules')->get('InputfieldCheckbox');
		$wp_attrInput->name = 'wp_attr';
		$wp_attrInput->columnWidth = 34;
		$wp_attrInput->label = __('Add Webp-Version');
		$wp_attrInput->description = __('Activate to add a Webp-version to each variation (since processwire 3.0.132).');
		if (!empty($data['wp_attr'])) $wp_attrInput->checked = 1;
		$wrapper->add($wp_attrInput);

		$wh_attrInput = wire('modules')->get('InputfieldCheckbox');
		$wh_attrInput->name = 'wh_attr';
		$wh_attrInput->columnWidth = 33;
		$wh_attrInput->label = __('Width/Height Attributes');
		$wh_attrInput->description = __('Activate to add the right width and height attribute.');
		if (!empty($data['wh_attr'])) $wh_attrInput->checked = 1;
		$wrapper->add($wh_attrInput);


		$data_attrInput = wire('modules')->get('InputfieldCheckbox');
		$data_attrInput->name = 'data_attr';
		$data_attrInput->columnWidth = 33;
		$data_attrInput->label = __('Data* attributes');
		$data_attrInput->description = __('Activate to add a data*- before the srcset and sizes attributes.');
		if (!empty($data['data_attr'])) $data_attrInput->checked = 1;
		$wrapper->add($data_attrInput);

		$ll_attrInput = wire('modules')->get('InputfieldCheckbox');
		$ll_attrInput->name = 'll_attr';
		$ll_attrInput->columnWidth = 34;
		$ll_attrInput->label = __('Use Lazysizes JS-plugin');
		$ll_attrInput->description = __('Activate to add Lazy loading. Forces data* attributes to be activated. Includes lazysizes.min.js. Adds the class "lazyload"');
		if (!empty($data['ll_attr'])) $ll_attrInput->checked = $data_attrInput->checked = 1;
		$wrapper->add($ll_attrInput);


		return $wrapper;
	}

	/**
	 * Get data by key
	 *
	 */

	public function __get($key) {
		return isset($this->data[$key]) ? $this->data[$key] : null;
	}

	/**
	 * Set data at given key
	 *
	 */

	public function __set($key, $value) {
		$this->data[$key] = $value;
	}

	public function formatValue(Page $page, Field $field, &$str) {
		//Get all image tags from the $str and place them in $images
		if (!preg_match_all('/<img[^>]+>/i', $str, $images)) return;
		#$images = $images[0];
		#echo "Bilder: "; var_dump($images);
		//#todo What happens if this is only 1 image?

		//Setup...
		$matches = array();
		$fileLocation = $this->wire("config")->urls->files;
		$sizes = array_map('intval', array_filter(explode(',', $this->resolutions), 'is_numeric'));
		#sort($sizes);
		$medias = array_map('intval', array_filter(explode(',', $this->medias), 'is_numeric'));
		#sort($medias);
		$borders = explode(',', $this->borders);
		#var_dump($sizes);
		$options = array('upscaling' => false, 'cropping' => true, 'webpAdd' => true, 'webpQuality' => 75);
		$options_low = array('upscaling' => true, 'cropping' => true, 'quality' => floor($this->wire("config")->imageSizerOptions['quality'] * 0.33), 'webpAdd' => true, 'webpQuality' => 65);
		#var_dump($this->wire('page')->images);

		$p = $this->wire('page');
		//Looping through all images
		foreach ($images[0] as $original) {

			//Building our new image string
			$new = '';
			$meta = array();
			$meta['pw_align'] = "";
			$meta['alt'] = "";
			$meta['source'] = "";
			$meta['width'] = 0;
			$meta['height'] = 0;

			$attribute = $strappend = '';
			if ($this->data_attr) {
				$attribute = "data-";
			}
			if ($this->ll_attr) {
				$this->class .= ' lazyload';
				$strappend = '<script src="' . $this->wire('config')->urls->$this . 'lazysizes.min.js' . '" async></script>';
			}

			/**
			 * The following code was taken and modified from Martijn Geerts and the TextformatterImageInterceptor module.
			 */
			//Get the PageImage from our image
			if (strpos($original, $fileLocation)) {
				#var_dump($original);
				//Find source image
				preg_match_all('/src=["|\'](.*?)["|\']/i', $original, $array);
				#echo "Bilder: ";
				#var_dump($array);
				if (!$array[1]) continue;
				$meta['source'] = $array[1][0]; // original

				// ProcessWire alignment done with a class
				preg_match_all('/class="(.*?)"/i', $original, $array);
				#var_dump($array);
				$meta['pw_align'] = isset($array[1][0]) ? $array[1][0] : null; // original

				//Get alt tag if it exists
				preg_match_all('/alt="(.*?)"/i', $original, $array);
				$meta['alt'] = isset($array[1][0]) ? $array[1][0] : null;

				// example: 1023/image-name.100x100.jpg
				$string = str_replace($fileLocation, "", $meta['source']);
				// create array
				$array = explode("/", $string);
				#echo "Pfadelemente {$string}:"; var_dump($array);
				#echo "Page: ".$this->wire('page')->id;
				// id of page where where image belongs to
				$meta['id'] = $array[0];
				// refering to to page where the image lives - if it is not the current page.
				if ($meta['id'] != $p->id)
					$p = $this->wire("pages")->get($meta['id']);

				// raw image variation name
				$variationName = $array[1];
				#echo $variationName;
				#echo $fileLocation.$variationName;

				#$i = 0;
				if ($p->images)
					foreach ($p->images as $imvar) {
						#$pagebilder[$p->id][++$i][] = $imvar->name;
						if ($variationName == $imvar->name) {
							$item = $imvar;
							break;
						} else {
							foreach ($imvar->getVariations() as $var) {
								#$pagebilder[$p->id][$i][] = $var->name;
								if ($variationName == $var->name) {
									$item = $var;
									break;
								}
							}
						}
					}
				else break;


				//Original File
				if ($item->isVariation($variationName)) {
					$parent = $item->getOriginal();
				} else {
					$parent = $item;
				}

				#var_dump($item);
				#var_dump($item->getOriginal());
				getimagesize($parent->filename, $info);
				$data = [];
				$meta['quelle'] = 'Baufuchs';
				if (array_key_exists('APP13', $info)) {
					$iptc = iptcparse($info['APP13']);
					//See https://github.com/Intervention/image/blob/master/src/Intervention/Image/Commands/IptcCommand.php
					if (is_array($iptc)) {
						$data['DocumentTitle'] = isset($iptc["2#005"][0]) ? $iptc["2#005"][0] : null;
						$data['Urgency'] = isset($iptc["2#010"][0]) ? $iptc["2#010"][0] : null;
						$data['Category'] = isset($iptc["2#015"][0]) ? $iptc["2#015"][0] : null;
						$data['Subcategories'] = isset($iptc["2#020"][0]) ? $iptc["2#020"][0] : null;
						$data['Keywords'] = isset($iptc["2#025"][0]) ? $iptc["2#025"] : null;
						$data['SpecialInstructions'] = isset($iptc["2#040"][0]) ? $iptc["2#040"][0] : null;
						$data['CreationDate'] = isset($iptc["2#055"][0]) ? $iptc["2#055"][0] : null;
						$data['CreationTime'] = isset($iptc["2#060"][0]) ? $iptc["2#060"][0] : null;
						$data['AuthorByline'] = isset($iptc["2#080"][0]) ? $iptc["2#080"][0] : null;
						$data['AuthorTitle'] = isset($iptc["2#085"][0]) ? $iptc["2#085"][0] : null;
						$data['City'] = isset($iptc["2#090"][0]) ? $iptc["2#090"][0] : null;
						$data['SubLocation'] = isset($iptc["2#092"][0]) ? $iptc["2#092"][0] : null;
						$data['State'] = isset($iptc["2#095"][0]) ? $iptc["2#095"][0] : null;
						$data['Country'] = isset($iptc["2#101"][0]) ? $iptc["2#101"][0] : null;
						$data['OTR'] = isset($iptc["2#103"][0]) ? $iptc["2#103"][0] : null;
						$data['Headline'] = isset($iptc["2#105"][0]) ? $iptc["2#105"][0] : null;
						$data['Source'] = isset($iptc["2#110"][0]) ? $iptc["2#110"][0] : null;
						$data['PhotoSource'] = isset($iptc["2#115"][0]) ? $iptc["2#115"][0] : null;
						$data['Copyright'] = isset($iptc["2#116"][0]) ? $iptc["2#116"][0] : null;
						$data['Caption'] = isset($iptc["2#120"][0]) ? $iptc["2#120"][0] : null;
						$data['CaptionWriter'] = isset($iptc["2#122"][0]) ? $iptc["2#122"][0] : null;
					}

					if (isset($data['Copyright'])) //Copyright
						$meta['quelle'] = $data['Copyright'];
					elseif (isset($data['Source'])) //Credits
						$meta['quelle'] = $data['Source'];
					elseif (isset($data['AuthorByline'])) //Author
						$meta['quelle'] = $data['AuthorByline'];

				}


				// basename of image.
				//$imageName = preg_replace("/\d+x\d+\./i","", $variationName);
				#$tmp1 = explode('.', $variationName);
				#$meta['imageName'] = $tmp1[0];
				#$meta['ext'] = $tmp1[count($tmp1) - 1];
				$meta['imageName'] = $item->name;
				$meta['ext'] = $item->ext;

				//Thanks to Horst Nogajski for the following snippet
				/*foreach ($p->fields as $field) {
					if (!(bool)($field->type instanceof FieldtypeImage)) continue; // if no images field, go on

					// find the field that holds the image
					if (!$p->get($field->name)->has('name=' . $meta['imageName'] . '.' . $meta['ext'])) continue;

					$image = $p->get($field->name)->get('name=' . $meta['imageName'] . '.' . $meta['ext']);
				}*/
				$image = $item;
				#echo "String: " . $string;
				//Get image size #todo use regex here
				/*$array = explode(".", $string);
				$array = substr($array[count($array) - 2], 0, -3); //Get the image tag and remove everything. results in e.g. 720x201
				$array = explode("x", $array);
				var_dump($array);
				if (count($array) == 2) //Shitty filtering in case it is the original image
					$meta['width'] = (int)$array[0];
				else
					$meta['width'] = $image->width;
				$meta['height'] = (int)$array[1]; //Height is set to always 0 by PW*/
				$meta['width'] = $item->width();
				$meta['height'] = $item->height();
			} else {
				//Nothing found
				break;
			}
			//$image is now our PageImage, $p the page of the Image

			/**
			 * Build the srcset
			 */

			$srcset = array();
			$smedia = array();
			$addon = '';

			//When no sizes are set
			if (empty($sizes)) {
				#$srcset[] = "{$meta['source']} 1x";
				$srcset[] = "{$item->url} 1x";
				//... and retina is active
				if ($this->retina) {
					//And our image is sized (e.g. larger image possible). Then we can provide a better image to HiDPI devices
					if ($parent->width() > $meta['width']) {
						//Create retina version
						$retina_image = $parent->size($meta['width'] * 2, 0, $options);
						$srcset[] = "{$retina_image->url} 2x";
					}
				}
			} else {
				//Sizes are set
				//For every size
				//Nur bei den "großen" Bildern - für baufuchs
				if ($meta['width'] > 300) {
					foreach ($sizes as $num => $size) {
						//Do we need this size as a source?
						#if ($size < $meta['width']) {

						//Orientation
						if ($image) {
							if ($image->width > $image->height) {
								$new_image = $image->size($size, 0, $options);
							} else {
								$new_image = $image->size(0, $size, $options);
							}
							$srcset[] = "{$new_image->url} {$new_image->width}w";
							$picture = new stdClass();
							//Zuerst webp und dann das normale - because browser takes first source which meets criteria defined in media
							if ($this->wp_attr)
								if ($new_image->hasWebp) {
									$picture->src = $new_image->webp->url;
									$picture->media = $medias[$num];
									$picture->border = $borders[$num];
									$picture->type = wire('config')->fileContentTypes($new_image->webp->ext);
									$smedia[] = $picture;
								}
							$picture = new stdClass();
							$picture->src = $new_image->url;
							$picture->media = $medias[$num];
							$picture->border = $borders[$num];
							$picture->type = wire('config')->fileContentTypes($new_image->ext);
							$smedia[] = $picture;
						}
					}

				}
				//If HiDPI is enabled
				if ($this->retina) {
					if ($parent->width() >= $meta['width']) {
						//Create retina version
						$retina_image = $parent->size($meta['width'] * 2, 0, $options);
					} else {
						//Use the largest image
						$retina_image = $image;
					}
					$srcset[] = "{$retina_image->url} {$retina_image->width}w";

					$addon .= '<source ' . $attribute . 'src="' . $retina_image->url . ' 2x, ' . $image->url . ' 1x" />';
				}

				//Remove the last comma
				#$srcset = substr($srcset, 0, -1);

			}
			$srcset = implode(',', $srcset);
			/**
			 * Build the src
			 */
			$src = $meta['source'];

			if ($this->lqp OR $this->small_source) {
				//Should we use the smallest image from the sizes?
				if ($this->small_source && !empty($sizes)) {
					//Orientation
					if ($image->width > $image->height) {
						$src_image = $image->size($sizes[0], 0, $options);
					} else {
						$src_image = $image->size(0, $sizes[0], $options);
					}
				} //Or do we really use a LQ image? Note, the 300 size is fixed here
				else {
					$new_size = floor($image->width * 0.2);
					$src_image = $image->size($new_size, 0, $options_low);
				}
				$src = $src_image->url;
			}


			/**
			 * Finally, Build the <img>
			 */

			$wh_attr = '';
			$class = '';


			if ($this->wh_attr) {
				$tmp_height = $image->size($meta['width'], 0)->height;
				$wh_attr = " width='{$meta['width']}' height='{$tmp_height}'";
			}

			if ($meta['pw_align'] != "" OR $this->class != "") {
				$class = " class='";
				if ($meta['pw_align'] != "")
					$class .= " {$meta['pw_align']} ";
				if ($this->class != '')
					$class .= " {$this->class}";
				$class .= "'";
			}

			if (count($smedia) > 0) {
				//Put it all together
				$new = "<picture>";
				foreach ($smedia as $med) {
					$new .= "<source media='(" . $med->border . ":" . $med->media . "px)' {$attribute}srcset='" . $med->src . "' type='$med->type'>";
				}
				if ($addon)
					$new .= $addon;
				$new .= "<img {$attribute}src='{$src}' data-sizes='{$this->sizes}' {$wh_attr} alt='{$meta['alt']}' title='{$meta['quelle']}' {$class}/>";
				$new .= "</picture>";


			} else {
				//Wenn das Originalbild kleiner ist, als die Responsive-Varianten, soll es unberührt bleiben, da es vermutlich im Text positioniert ist.
				$new = $original;
				if ($this->wp_attr) {
					//generate a WEBP-Version (since processwire 3.0.132)
					//https://processwire.com/blog/posts/webp-images-in-pw/
					if ($image) {
						$wp = $image->webp();
						$type = $this->wire('config')->fileContentTypes($wp->ext);
						$new = "<picture>";
						$new .= "<source {$attribute}srcset='" . $wp->url . "' type='$type'>";
						$new .= $addon;
						$new .= "<img {$attribute}src='{$image->url}' data-sizes='{$this->sizes}' {$wh_attr} alt='{$meta['alt']}' title='{$meta['quelle']}' {$class} />";
						$new .= "</picture>";
					}
				}
			}
			//Add to our new images
			$matches[] = $new;

		}

		//Replace all Image tags with our new ones and return.
		$str = str_replace($images[0], $matches, $str) . $strappend;
		return;
	}
}